<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><link rel="stylesheet" type="text/css" href="flow0001.css" />
<title>part0007</title>
</head>
<body>
<div id="a1PG" class="heading_sA5">Persistent Volumes</div>
<div>Storage management from computing installations is an amazing hassle. The Persistent Volume subsystem provides an API for clients and administrators that describes how storage is done, how it is consumed. To do this, we introduce new API resources: Persistent Volume and Persistent Volume Claim.</div>
<div class="class_s2V">A Persistent Volume (PV) is a piece of storage in a cluster that has been provisioned through an administrator or to dynamically use storage classes. It is an aid in a cluster such that a node is a cluster resource. There are only limited plugins like PV volume, however, any character pod has a lifecycle fair in which PV is used. This API captures the details of the implementation of object storage, be it NFS, iSCSI or cloud-provider-specific storage systems.</div>
<div class="class_s2V">A Persistent Volume Claim (PVC) is a request for storage through the user. It is similar to a pod. Pod nodes consume resources and PVCs consume PV resources. Pods can request precise levels of assets (CPU and memory). Claims can request unique shapes and enter mode (eg, they can be set to read/write once or read-only multiple times).</div>
<div class="class_s2V">While Persistent Volume Claims allows the individual to eat intangible storage resources, it is often the case that users want Persistent Volumes with different properties for one-of-a-kind problems, such as performance. Cluster administrators want to be in a position to provide a range of Persistent Volumes, which range in more perspectives than measurement and access modes, leaving clients how these volumes are implemented. For these needs, Storage Class is the resource.</div>
<div class="class_s2Y">See special walkthrough with examples of work.</div>
<div class="class_s2Y">A limit and claim of life</div>
<div>PV clusters have resources. PVCs request these assets and also act as a claim test for the resource. The interaction between PV and PVC follows this life cycle:</div>
<div id="page_43" class="class_s2Y">Provisioning</div>
<div>There are approaches PV can also be provisioned: statistically or dynamically.</div>
<div class="class_s2Y">Fixed</div>
<div>A cluster administrator creates a wide variety of PVs. They enhance the details of the actual storage, which is accessible for use through cluster users. They exist in the Kubernetes API and are available for consumption.</div>
<div class="class_s2Y">Dynamic</div>
<div>When a static PV is none of the administrators created in the shape of the user's PersistentVolumeClaim, the cluster may try to provision a volume dynamically specifically for the PVC. This provision is mainly based on StorageClasses: PVC must request a storage class and the administrator must create and configure that classification for dynamic provisioning. Claims that request classification "successfully disable dynamic provisioning for themselves.</div>
<div class="class_s2V">To allow dynamic storage provisioning based solely on the storage class, the cluster administrator needs to enable the DefaultStorageClass access controller on the API server. This can be done, for example, by ordering the list of values ​​for the --enable-entry-plug-in flag of the API Server component by ensuring that DefaultStorageClass is comma-delimited. For additional information about API server command-line flags, check the cube-appeaser documentation.</div>
<div class="class_s2Y">Binding</div>
<div>A consumer creates, or in the case of dynamic provisioning, already built, a PersistentVolumeClaim a unique amount of storage with requested and fixed access modes. The master clocks for the new PVC find a control loop, a matching PV (if possible), and bind them together. If a PV is dynamically provisioned for a new PVC, the loop will always bind that PV to the PVC. Otherwise, the user will always get at least what they asked for, although this quantity may exceed what was once requested. Once bound, PersistentVolumeClaim binds are exclusive, regardless of how they are bound. A PVC to PV <span id="page_44"></span>
 binding is a one-to-one mapping.</div>
<div class="class_s2V">If a matching quantity no longer exists, the claims will remain indefinitely. Claims will be bound by matching clauses as they become available. For example, a cluster provisioned with multiple 50Gi PVs will no longer correspond to PVCs requesting 100Gi. PVC can be bound when 100Gi PV is delivered to the cluster.</div>
<div class="class_s2Y">using the</div>
<div>Pods use the claims as a volume. Cluster Bound declares the volume to be detected and measures that volume for the pod. For versions that help gain access to multiple modes, the individual specifies which mode is preferred when their declaration is used as a volume in the pod.</div>
<div class="class_s2V">Once a user claims and is bound to announce, the fixed PV is for the consumer, as long as they need it. Users periodically eat pods and take entries in their claimed PV, including a permanent clam code in their pod's volume block. See syntax for details.</div>
<div class="class_s2Y">Storage in use protection</div>
<div>The purpose of the storage object in the Usage Protection feature is to ensure that live volume claims (PVCs) through continuous pods and constant volumes (PVs) that are fixed to PVCs are no longer eliminated from the system, as this is also information. The end results in a loss.</div>
<div class="class_s2V">Note: PVC is in energetic use through a pod when a pod object exists which is the use of PVC.</div>
<div>If a consumer removes the PVC in active use through the pod, the PVC is not removed immediately. The removal of PVC is postponed until PVC is no longer actively used through any pods. Also, if an administrator removes a PV that is certain to a PVC, the PV is not terminated immediately. The PV is postponed until the PV is fixed to a PVC.</div>
<div class="class_s2V">You can see that a PVC is included when the PVC is being depleted and the final list includes kubernetes.io/pvc-protection:</div>
<div id="page_45" class="class_sH6">Kubernetes describe PVC host path</div>
<div class="class_s5K">Name:          host path</div>
<div class="class_s5K">Namespace:     default</div>
<div class="class_s5K">StorageClass:  example-host path</div>
<div class="class_s5K">Status:        Terminating</div>
<div class="class_s5K">Volume:</div>
<div class="class_s5K">Labels:        &lt;none&gt;</div>
<div class="class_s5N">
<span class="class_s1PT">Annotations:   volume.beta.kubernetes.io/storage-class</span>
 <span class="class_s1PV">=</span>
 <span class="class_s1PT">example-hostpath</span>
</div>
<div class="class_s5N">
<span class="class_s1PT">               volume.beta.kubernetes.io/storage-provisioner</span>
 <span class="class_s1PV">=</span>
 <span class="class_s1PT">example.com/hostpath</span>
</div>
<div class="class_s5N">
<span class="class_s1PT">Finalizers:    </span>
 <span class="class_s1PV">[</span>
 <span class="class_s1PT">kubernetes.io/pvc-protection</span>
 <span class="class_s1PV">]</span>
</div>
<div class="class_sHJ">
<span class="class_s1PX">Reclaiming</span>
</div>
<div class="class_sHJ">
<span class="class_s1PS">When a consumer is finished with their volume, they can remove PVC objects from the API that allow resource recapture. The retrieval policy for a PersistentVolume tells the cluster what to do after its assertion is released. Currently, volumes can either be created, recycled, or removed.</span>
</div>
<div class="class_sHR">
<span class="class_s1PX">Keep to</span>
</div>
<div class="class_sHJ">
<span class="class_s1PS">The Written Reclam Coverage allows for a guide recall of the resource. After PersistentVolumeClaim is removed, PersistentVolume still exists and the volume is considered to be "released". But it is still not available due to the fact that the previous contender's records remain on volume. An administrator can manually retrieve the range with the following steps.</span>
</div>
<div class="class_sHR">
<span class="class_s1PS">Remove persistent volume. Storage assets belonging to external infrastructure (such as AWS EBS, GCE PD, Azure Disk, or Cinder volumes), however, exist after the PV is destroyed.</span>
</div>
<div class="class_sHJ">
<span class="class_s1PS">Manually simplify the data on the respective storage asset accordingly.</span>
</div>
<div class="class_sHJ">
<span class="class_s1PS">Manually remove the associated storage asset, or if you favor reusing the same storage asset, create a new PersistentVolume with <span id="page_46"></span>
 the storage asset definition.</span>
</div>
<div class="class_sHJ">
<span class="class_s1PX">Remove</span>
</div>
<div class="class_sHJ">
<span class="class_s1PS">For volume plugins that guide the delete recall policy, the deletions relieve each PersistentVolume object in Kubernetes, as well as associated storage assets in external infrastructures, such as AWS EBS, GCE PD, Aziz Disk or Cinder Volume. Volumes that are provisioned dynamically inherit the recall coverage of their storage class, which defaults to delete. Administrators should configure StorageClass according to users' expectations; Otherwise, the PV must be edited or patched after creating it. See Change the recovery policy of a PersVolume.</span>
</div>
<div class="class_sHR">
<span class="class_s1PX">Recycle</span>
</div>
<div class="class_sHJ">
<span class="class_s1PS">Warning: Recycle Reclaim Policy has been removed. Instead, the strategy of advocacy is to use dynamic provision.</span>
</div>
<div class="class_sHJ">
<span class="class_s1PS">If the underlying volume is supported via the plugin, the Recycle Reclaim Policy performs a primary scrub (rm -rf / the volume / *) at this limit and once again hands it over for a new claim.</span>
</div>
<div class="class_sHR">
<span class="class_s1PS">However, an administrator can configure the use of Kubernetes Controller Manager command-line arguments to the custom Recycler pod template as described here. The custom recycler pod template must include a volume specification, as proven in the example below:</span>
</div>
<div class="class_sHR">
<span class="class_s1PS">However, in the volume stage, the exact specific direction in the Custom Recycler Pod Template is replaced by the exact direction of the level that is being recycled.</span>
</div>
<div class="class_sHR">
<span class="class_s1PX">Continuously expanding volume claims</span>
</div>
<div class="class_sHJ">
<span class="class_s1PS">Support to increase persistent volume claims (PVCs) is now enabled <span id="page_47"></span>
 by default. You can increase the following types of volumes:</span>
</div>
<div class="class_sHR">
<span class="class_s1PS">GCE persistent disk</span>
</div>
<ul class="class_sJV">
<li class="class_s68">awsElasticBlockStore</li>
<li class="class_s68">The ashes</li>
<li class="class_s68">Clusters</li>
</ul>
<ul class="class_s8">
<li class="class_s68">RBD</li>
<li class="class_s68">Azure File</li>
<li class="class_s68">Azure Disc</li>
<li class="class_s68">Forex</li>
<li class="class_s68">FlexVolumes</li>
<li class="class_s68">CSI</li>
<li class="class_s68">If the allowVolumeExpansion theme of your storage class is correct, you can only raise a PVC.</li>
<li class="class_s68">apiVersion: storage.k8s.io/v1</li>
<li class="class_s68">Like: StorageClass</li>
<li class="class_s68">Metadata:</li>
<li class="class_s68">names: brightness-volume-default</li>
<li class="class_s68">Provider: kubernetes.io/glusterfs</li>
<li class="class_s68">Parameter:</li>
<li class="class_s68">rest URL: "http://192.168.10.100:8080"</li>
<li class="class_s68">restrooms: ""</li>
<li class="class_s68">secret names: ""</li>
<li class="class_s68">secret names: ""</li>
</ul>
<div class="class_sHJ">
<span class="class_s1PS">allowVolumeExpansion: true</span>
</div>
<div class="class_sHJ">
<span class="class_s1PS">To request a larger quantity for a PVC, edit the PVC object and specify a larger size. This triggers an increase in the range that the underlying PersistentVolume supports. A new PersistentVolume claim is not created in any way to fulfill. Instead, an existing volume is resized.</span>
</div>
<div class="class_sHR">
<span class="class_s1PX">CSI Volume Expansion</span>
</div>
<div class="class_sHR">
<span class="class_s1PS">Support for CSI volume expansion is enabled using defaults, but a <span id="page_48"></span>
 special CSI driver is also required to assist in volume expansion. Refer to the documentation of the specific CSI driver for additional information.</span>
</div>
<div class="class_sHR">
<span class="class_s1PX">Resizing a volume containing a file system</span>
</div>
<div class="class_sHJ">
<span class="class_s1PX">If the file device is XFS, Ext3, or Ext4, you can resize only file machine versions.</span>
</div>
<div class="class_sHR">
<span class="class_s1PS">When a quantity moves the file system, the file device size is only when a new pod uses PersistentVolumeClaim in ReadWrite mode. The file gadget extension is completed either when a pod is starting or when a pod is running and the underlying file machine supports online expansion.</span>
</div>
<div class="class_sHR">
<span class="class_s1PS">The size of the Flex Volumes permit is changed, if the driver is required, this is true. Flex Volume can be changed on pod restart.</span>
</div>
<div class="class_sHR">
<span class="class_s1PX">Resizing in-use Persistent Volume Claim</span>
</div>
<div class="class_sHJ">
<span class="class_s1PS">In this case, you do not need to remove and recreate the pod or deployment that is the use of current PVC. Any using PVC automatically gets on hand quickly for its pod as its file system has been expanded. This feature has no effect on PVCs that are no longer in use by a pod or deployment. You need to make a pod that uses already enhanced PVC.</span>
</div>
<div class="class_sHR">
<span class="class_s1PS">Similar to a wide variety of types – Flex Volume volume can also be increased when used via pod.</span>
</div>
<div class="class_sHR">
<span class="class_s1PS">Note: FlexVolume size change is only feasible when the underlying driver supports the size.</span>
</div>
<div class="class_sHJ">
<div id="page_49">
<span class="class_s1PS">Note: The expansion of EBS versions is a time-consuming action. In addition, there is a per-volume quota of one revision every 6 hours.</span>
</div>
</div>
<div class="class_sHJ">
<span class="class_s1PS">Constant Volume Type</span>
</div>
<div class="class_sHJ">
<span class="class_s1PS">PersistentVolume types are implemented as plugins. Kubernetes currently supports the following plugins:</span>
</div>
<ul class="class_sNY">
<li class="class_s68">GCEPersistentDisk</li>
<li class="class_s68">AWSElasticBlockStore</li>
<li class="class_s68">AzureFile</li>
<li class="class_s68">AzureDisk</li>
<li class="class_s68">CSI</li>
<li class="class_s68">FC (Fiber Channel)</li>
<li class="class_s68">FlexVolume</li>
<li class="class_s68">Flocker</li>
<li class="class_s68">NFS</li>
<li class="class_s68">iSCSI</li>
<li class="class_s68">RBD (Sif Block Device)</li>
<li class="class_s68">Cephfs</li>
<li class="class_s68">Cinder (OpenStack block storage)</li>
<li class="class_s68">Clusters</li>
<li class="class_s68">VsphereVolume</li>
<li class="class_s68">Quobyte Volume</li>
</ul>
<div class="class_sHJ">
<span class="class_s1PS">HostPath (trying only nodes - neighborhood storage is no longer supported in any way and will not work in a multi-node cluster)</span>
</div>
<ul class="class_sJV">
<li class="class_s68">Perks volume</li>
<li class="class_s68">Sale Volume</li>
<li class="class_s68">StorageOS</li>
<li class="class_s68">Constant volume</li>
</ul>
<div class="class_sHJ">
<span class="class_s1PS">Each PV has an imagination and position, which is the uniqueness and prestige of the volume.</span>
</div>
<div class="class_sPE">
<div id="page_50">You can see that a PV is protected when the PV’s status is <span class="class_s1RF">Terminatin</span>
 <span class="class_s1RG">g</span>
 and the <span class="class_s1RF">Finalizer</span>
 <span class="class_s1RG">s</span>
 list includes <span class="class_s1RF">kubernetes.io/pv-protectio</span>
 <span class="class_s1RG">n</span>
 too:</div>
</div>
<div class="class_s5K">Kubernetes describe PV task-PV-volume</div>
<div class="class_s5K">Name:            task-PV-volume</div>
<div class="class_s5N">
<span class="class_s1PT">Labels:          </span>
 <span class="class_s1PU">type</span>
 <span class="class_s1PV">=</span>
 <span class="class_s1PW">local</span>
</div>
<div class="class_s5K">Annotations:     &lt;none&gt;</div>
<div class="class_s5N">
<span class="class_s1PT">Finalizers:      </span>
 <span class="class_s1PV">[</span>
 <span class="class_s1PT">kubernetes.io/pv-protection</span>
 <span class="class_s1PV">]</span>
</div>
<div class="class_s5K">StorageClass:    standard</div>
<div class="class_s5K">Status:          Available</div>
<div class="class_s5K">Claim:</div>
<div class="class_s5K">Reclaim Policy:  Delete</div>
<div class="class_s5K">Access Modes:    RWO</div>
<div class="class_s5K">Capacity:        1Gi</div>
<div class="class_s5K">Message:</div>
<div class="class_s5K">Source:</div>
<div class="class_s5N">
<span class="class_s1PT">    Type:          HostPath</span>
 <span class="class_s1PV">(</span>
 <span class="class_s1PT">bare host directory volume</span>
 <span class="class_s1PV">)</span>
</div>
<div class="class_s5K">    Path:          /Tmp/data</div>
<div class="class_s5K">    HostPathType:</div>
<div class="class_sR1">
<span class="class_s1PT">Events:            &lt;none&gt;</span>
</div>
<div class="class_sR3">
<span class="class_s1PT">apiVersion:</span>
 <span class="class_s1PT">v1</span>
</div>
<div class="class_s5N">
<span class="class_s1PT">kind:</span>
 <span class="class_s1PT">PersistentVolume</span>
</div>
<div class="class_s5K">metadata:</div>
<div class="class_s5N">
<span class="class_s1R0">  </span>
 <span class="class_s1PT">name:</span>
 <span class="class_s1PT">pv0003</span>
</div>
<div class="class_s5K">spec:</div>
<div class="class_s5N">
<span class="class_s1R0">  </span>
 <span class="class_s1PT">capacity:</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">    </span>
 <span class="class_s1PT">storage:</span>
 <span class="class_s1PT">5Gi</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">  </span>
 <span class="class_s1PT">volumeMode:</span>
 <span class="class_s1PT">Filesystem</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">  </span>
 <span class="class_s1PT">accessModes:</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">    </span>
 <span class="class_s1PT">-</span>
 <span class="class_s1PT">ReadWriteOnce</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">  </span>
 <span class="class_s1PT">persistentVolumeReclaimPolicy:</span>
 <span class="class_s1PT">Recycle</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">  </span>
 <span class="class_s1PT">storageClassName:</span>
 <span class="class_s1PT">slow</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">  </span>
 <span class="class_s1PT">mountOptions:</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">    </span>
 <span class="class_s1PT">-</span>
 <span class="class_s1PT">hard</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">    </span>
 <span class="class_s1PT">-</span>
 <span class="class_s1PT">nfsvers=</span>
 <span class="class_s1PV">4.1</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">  </span>
 <span class="class_s1PT">nfs:</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">    </span>
 <span class="class_s1PT">path:</span>
 <span id="page_51"></span>
 <span class="class_s1PT">/tmp</span>
</div>
<div class="class_sR1">
<span class="class_s1R0">    </span>
 <span class="class_s1PT">server:</span>
 <span class="class_s1PV">172.17.0.2</span>
</div>
<div class="class_sRP">
<span class="class_s1PT">apiVersion:</span>
 <span class="class_s1PT">v1</span>
</div>
<div class="class_s5N">
<span class="class_s1PT">kind:</span>
 <span class="class_s1PT">PersistentVolume</span>
</div>
<div class="class_s5K">metadata:</div>
<div class="class_s5N">
<span class="class_s1R0">  </span>
 <span class="class_s1PT">name:</span>
 <span class="class_s1PT">block-PV</span>
</div>
<div class="class_s5K">spec:</div>
<div class="class_s5N">
<span class="class_s1R0">  </span>
 <span class="class_s1PT">capacity:</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">    </span>
 <span class="class_s1PT">storage:</span>
 <span class="class_s1PT">10Gi</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">  </span>
 <span class="class_s1PT">accessModes:</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">    </span>
 <span class="class_s1PT">-</span>
 <span class="class_s1PT">ReadWriteOnce</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">  </span>
 <span class="class_s1PT">volumeMode:</span>
 <span class="class_s1PT">Block</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">  </span>
 <span class="class_s1PT">persistentVolumeReclaimPolicy:</span>
 <span class="class_s1PT">Retain</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">  </span>
 <span class="class_s1PT">Fc:</span>
</div>
<div class="class_sS3">The ability</div>
<div class="class_s61">Generally, a PV will have accurate storage capacity. This is a potential feature set use of PV. View the Kubernetes resource model to obtain the tools required with the help of capability.</div>
<div class="class_s5Z">Currently, storage size is the only support that can be set or requested. Future features may include IOPS, throughput, etc.</div>
<div class="class_s6S">Volume mode</div>
<div class="class_s61">Feature State: Kubernetes v1.13 beta</div>
<div class="class_s61">Prior to Kubernetes 1.9, all volume plugins created a file system on a continuous volume. Now, you can block the price of the volume code to use a blocked device, or block the filesystem to use the file system. If the value is omitted, the filesystem is the default. This is an optionally available API parameter.</div>
<div class="class_s6S">access mode</div>
<div class="class_s61">A PersistentVolume can be installed on a host in any way with the help of a resource provider. As proven in the table below, companies will have exceptional capabilities and every PV's entry to <span id="page_52"></span>
 the mode is set to the particular mode supported using this particular volume. For example, NFS can help more than one read/write client, although a unique NFS PV would likely be exported to a read-only server. Each PV gets its own very precise set of options, which describe the exact PV capabilities.</div>
<div class="class_s6S">Enter Mode:</div>
<div class="class_s5Z">ReadWriteOnce - Can be set up as read-write through a node</div>
<div class="class_s61">ReadOnlyMany - Quantities can only be read by multiple nodes</div>
<div class="class_s61">ReadWriteMany - Volumes can be set up as read-write with the help of multiple nodes</div>
<div class="class_s61">In the CLI, the short form for entering mode is:</div>
<ul class="class_s6P">
<li class="class_s68">RWO - ReadWriteOnce</li>
<li class="class_s68">ROX - ReadOnlyMany</li>
<li class="class_s68">RWX - ReadWriteMany</li>
</ul>
<div class="class_s61">Important! A volume can be set to use one access mode at a time, even if it helps many. For example, a GCEPersistentDisk can be set up through multiple nodes as a single node or ReadOnlyMany as ReadWriteOnce, but no longer at the same time.</div>
<div class="class_s6S">class</div>
<div class="class_s61">A PV may contain a class, which is targeted through placing the StorageClassName attribute with the title of StorageClass. A unique class of PV can only be ensured for PVCs urging for that class. There is no type of PVClassName with no storage and can only be fixed for PVCs that do not request an exact class.</div>
<div class="class_s5Z">In the past, the annotation volume.beta.kubernetes.io/storage-class has been used as an alternative to the storage class name attribute. This annotation is still working; However, it will be fully demoted in future Kubernetes releases.</div>
<div class="class_s6S">Retrieval policy</div>
<div class="class_s61">Current reclaimed insurance policies are:</div>
<div class="class_s6S">Written - Guide Reclamation</div>
<div class="class_s61">Recycle - Original Scrub (rm -rf / the volume / *)</div>
<div id="page_53" class="class_s61">Delete - Related storage assets such as AWS EBS, GCE PD, Azure Disk, or OpenStack cinder limit are removed</div>
<div class="class_s61">Currently, only NFS and host paths support recycling. AWS EBS, GCE PD, Azure Disk, and Cinder Volume Assist deletion.</div>
<div class="class_s6S">Mount option</div>
<div class="class_s61">A Kubernetes administrator can specify additional mount pics when a mountain volume is mounted on a node.</div>
<div class="class_s5Z">Note: Not all permanent volume types help mount options.</div>
<div class="class_s61">The following types help mount options:</div>
<ul class="class_s6P">
<li class="class_s68">AWSElasticBlockStore</li>
<li class="class_s68">AzureDisk</li>
<li class="class_s68">AzureFile</li>
<li class="class_s68">Cephfs</li>
<li class="class_s68">Cinder (OpenStack block storage)</li>
<li class="class_s68">GCEPersistentDisk</li>
<li class="class_s68">Clusters</li>
<li class="class_s68">NFS</li>
<li class="class_s68">Quobyte Volume</li>
<li class="class_s68">RBD (Sif Block Device)</li>
<li class="class_s68">StorageOS</li>
<li class="class_s68">VsphereVolume</li>
<li class="class_s68">iSCSI</li>
</ul>
<div class="class_s61">Mount selections are no longer valid, so if one is invalid the mount will actually fail.</div>
<div class="class_sU2">
<span class="class_s1R0">    </span>
 <span class="class_s1PT">targetWWNs:</span>
 <span class="class_s1PT">[</span>
 <span class="class_s1R5">"50060e801049cfd1"</span>
 <span class="class_s1PT">]</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">    </span>
 <span class="class_s1PT">lun:</span>
 <span class="class_s1PV">0</span>
</div>
<div class="class_sU6">
<span class="class_s1RA">    </span>
 <span class="class_s1RB">readOnly:</span>
 <span class="class_s1RC">false</span>
</div>
<div class="heading_sU9">
<div id="a1PH">
<span class="class_s1R6">Persistent Volume Claim requesting a Raw Block Volume</span>
</div>
</div>
<div class="class_s5N">
<span class="class_s1PT">apiVersion:</span>
 <span class="class_s1PT">v1</span>
</div>
<div class="class_s5N">
<span class="class_s1PT">kind:</span>
 <span class="class_s1PT">PersistentVolumeClaim</span>
</div>
<div class="class_s5K">metadata:</div>
<div class="class_s5N">
<span class="class_s1R0">  </span>
 <span class="class_s1PT">name:</span>
 <span class="class_s1PT">block-pvc</span>
</div>
<div class="class_s5K">spec:</div>
<div class="class_s5N">
<span class="class_s1R0">  </span>
 <span id="page_54"></span>
 <span class="class_s1PT">accessModes:</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">    </span>
 <span class="class_s1PT">-</span>
 <span class="class_s1PT">ReadWriteOnce</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">  </span>
 <span class="class_s1PT">volumeMode:</span>
 <span class="class_s1PT">Block</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">  </span>
 <span class="class_s1PT">resources:</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">    </span>
 <span class="class_s1PT">requests:</span>
</div>
<div class="class_sU6">
<span class="class_s1R0">      </span>
 <span class="class_s1PT">storage:</span>
 <span class="class_s1PT">10Gi</span>
</div>
<div class="heading_sU9">
<div id="a1PJ">
<span class="class_s1PZ">Pod specification adding Raw Block Device path in container</span>
</div>
</div>
<div class="class_s5N">
<span class="class_s1PT">apiVersion:</span>
 <span class="class_s1PT">v1</span>
</div>
<div class="class_s5N">
<span class="class_s1PT">kind:</span>
 <span class="class_s1PT">Pod</span>
</div>
<div class="class_s5K">metadata:</div>
<div class="class_s5N">
<span class="class_s1R0">  </span>
 <span class="class_s1PT">name:</span>
 <span class="class_s1PT">pod-with-block-volume</span>
</div>
<div class="class_s5K">spec:</div>
<div class="class_s5N">
<span class="class_s1R0">  </span>
 <span class="class_s1PT">containers:</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">    </span>
 <span class="class_s1PT">-</span>
 <span class="class_s1PT">name:</span>
 <span class="class_s1PT">fc-container</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">      </span>
 <span class="class_s1PT">image:</span>
 <span class="class_s1PT">fedora:</span>
 <span class="class_s1PV">26</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">      </span>
 <span class="class_s1PT">command:</span>
 <span class="class_s1PT">[</span>
 <span class="class_s1R5">"/bin/sh"</span>
 <span class="class_s1PT">,</span>
 <span class="class_s1R5">"-c"</span>
 <span class="class_s1PT">]</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">      </span>
 <span class="class_s1PT">args:</span>
 <span class="class_s1PT">[</span>
 <span class="class_s1R5">"tail -f /dev/null"</span>
 <span class="class_s1PT">]</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">      </span>
 <span class="class_s1PT">volumeDevices:</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">        </span>
 <span class="class_s1PT">-</span>
 <span class="class_s1PT">name:</span>
 <span class="class_s1PT">data</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">          </span>
 <span class="class_s1PT">devicePath:</span>
 <span class="class_s1PT">/dev/xvda</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">  </span>
 <span class="class_s1PT">volumes:</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">    </span>
 <span class="class_s1PT">-</span>
 <span class="class_s1PT">name:</span>
 <span class="class_s1PT">data</span>
</div>
<div class="class_s5N">
<span class="class_s1R0">      </span>
 <span class="class_s1PT">persistentVolumeClaim:</span>
</div>
<div class="class_sR1">
<span class="class_s1R0">        </span>
 <span class="class_s1PT">claimName:</span>
 <span class="class_s1PT">block-pvc</span>
</div>
<div class="class_s2V">Formerly, Annotation Vol. Beta.kubernetes.io/mount-options was optionally used as a mounting attribute. This annotation is still working; However, it will be fully demoted in future Kubernetes releases.</div>
<div class="class_s2Y">Node affinity</div>
<div>Note: For most types of types, you no longer want to set this field. It is automatically populated for AWS EBS, GCE PD, and Azure disk volume block types. You want to explicitly set it for nearby versions.</div>
<div id="page_55">A PV node can specify the affinity to define constraints that impose restrictions on the extent to which this limit can be reached. Pods that use a PV will only be scheduled for nodes selected by node nodes.</div>
<div class="class_s2V">State</div>
<div>A quantity will be in one of the following steps:</div>
<div class="class_s2V">Available - a free useful resource that is not yet bound to claim</div>
<div>Bound - The limit is fixed to a claim</div>
<div>Issued - Claim has been removed, although this support is no longer received through the cluster</div>
<div>Failed - Volume has failed its automatic fix</div>
<div>The CLI will demonstrate the title of PVC to PV.</div>
<div class="class_s2Y">Persistent Volume Claims</div>
<div class="class_s2Y">access mode</div>
<div>The same conventions as claims are used when pleading for storage grants the right of entry into the mode.</div>
<div class="class_s2Y">Volume mode</div>
<div>Claims use a volume to indicate a volume as a filesystem or block device.</div>
<div class="class_s2Y">Resources</div>
<div>Claims, such as pods, can request the exact amount of processing. In this case, there is a request for storage. The same resource mannequin applies to each version and claims.</div>
<div class="class_s2Y">Selector</div>
<div>Claims can specify a label selector to filter a set of volumes. Only volumes whose labels suit the selector can be sure to claim. The selector may consist of  fields:</div>
<div class="class_s2V">
<span class="class_s1R2">MatchLabels -</span>
 Volume must have a label with this value</div>
<div>match expressions - A list of requirements created through specifying keys, lists of values, and operators that relate to keys and values. Legitimate operators include In, Not, Exist, and <span class="class_s1R2">Dontotist.</span>
</div>
<div id="page_56">All the requirements from each MatchLabels and MatchExpress are ended together - they all need to rest to match.</div>
<div class="class_s2Y">class</div>
<div>A declaration can request the use of the attribute StorageClassName with the help of specifying the storage class identity to a specific class. Only PVs of the requested class, as PVCs with similar storage, can be fixed to PVCs.</div>
<div class="class_s2V">PVC does not always have to request a class. With its storage, a PVC is set equal to the "classman", which is interpreted consistently to query for PV without a class, so it is only for PV with no classification (no annotation or an equivalent of " Set) can be fixed with. A PVCClassName with no storage is no longer very similar and is otherwise handled with the help of a cluster, depending on whether the DefaultStorageClass entry The term has become plugin.</div>
<div class="class_s2V">If the Access plugin is turned on, the administrator can additionally specify a default StorageClass. All PVCs that do not have a StorageClassName can only be fixed for PVs of that default. Specifying the default storage class is accomplished with the help of putting the annotation storageclass.kubernetes.io/is-default-class equal to authentic in the storage class object. If the administrator no longer specifies the default, the cluster responds to the PVC arrival as if the access plugin was turned off. If more than one default is specified, the Access plugin forbids the introduction of all PVCs.</div>
<div>If the Access plugin is turned off, the default StorageClass has no idea. All PVCs that do not have a StorageClassName can be guaranteed only for PVs that do not have a class. In this case, PVCs that do not have a StorageClassName are dealt with in the same way that PVCs have their StorageClassName set to ".</div>
<div>Depending on the installation method, a default StorageClass can additionally be deployed to the Kubernetes cluster using the addon manager during installation.</div>
<div class="class_s2V">When one specifies a selector in addition to querying for StorageClass, the requirements are ended together: only a PV of the requested class and with the requested label can also be fixed for PVC.</div>
<div id="page_57" class="class_s2V">Note: Currently, a PVC with a non-blank selector cannot dynamically provision a PV for it.</div>
<div>In the past, Annotation Vol. Beta.kubernetes.io/storage-class was once used as an alternative to the StorageClassName attribute. This annotation is still working; However, this will not be supported in future Kubernetes releases.</div>
<div class="class_s2Y">Claims as Vol</div>
<div>The pod is used using the assertion as a volume. Claims need to exist in the same namespace as the claims are used. The cluster finds the declaration in the pod's namespace and uses it to support assertions to Persistent Volume. The volume is then applied to the host and pod.</div>
<div class="class_s2Y">A note on namespaces</div>
<div>Persistent Volumes binds are exclusive, and objects considered Persistent Volume Claims are named, with "multiple" modes (ROX, RWX) increasing assertions possible only within a namespace.</div>
<div class="class_s2V">Raw <span class="class_s1R2">block volume support</span>
</div>
<div>Feature State: Kubernetes v1.13 beta</div>
<div>Plugins with the following limits support raw block volumes, together with dynamic provisioning of applied space:</div>
<ul class="class_s6P">
<li class="class_sBF">AWSElasticBlockStore</li>
<li class="class_sBF">AzureDisk</li>
<li class="class_sBF">FC (Fiber Channel)</li>
<li class="class_sBF">GCEPersistentDisk</li>
<li class="class_sBF">iSCSI</li>
<li class="class_sBF">Local quantity</li>
<li class="class_sBF">RBD (Sif Block Device)</li>
<li class="class_sBF">VsphereVolume (alpha)</li>
</ul>
<div>Note: Only FC and iSCSI volumes supported raw block volumes in Kubernetes 1.9. Support for additional plugins was introduced in 1.10.</div>
<div>The constant volume uses raw block volume</div>
<div class="class_s2Y">Binding block volume</div>
<div>If a person requests a raw block volume using the volume mode <span id="page_58"></span>
 discipline in PersistentVolumeClaim spec, the binding rules differ slightly from the preceding releases that do not consider this mode to be part of the spec. Listed is a table of feasible combos and the consumer will likely specify to request an uncovered block device.</div>
<div class="class_s2V">Volume snapshot and restore volume with snapshot support</div>
<div class="class_s2V">The volume photo function was added only to help CSI volume plugins. For details, see Volume Snapshot.</div>
<div class="class_s2V">To enable the guide to restore a volume from a volume image record source, allow the VolumeSnapshotDas source function gate on the approver and controller-manager.</div>
<div class="class_s2Y">Portable configuration writing</div>
<div>If you are writing configuration templates or examples that run on a wide range of clusters and want persistent storage, it is encouraged that you use the following pattern:</div>
<div class="class_s2V">Include PersistentVolumeClaim objects in your bundle with configuration (with deployment, config map, etc.).</div>
<div>Now do not include the PersistentVolume object in the configuration, except that the person configuring may not have permission to create PersistentVolumes other than this.</div>
<div>When instantiating a template, give the person the option to provide a storage classification name.</div>
<div>If the user presents a storage category name, insert that charge into the pure volume Claim. storage ClassName field. This would cause PVC to match the correct storage classification if StorageClasses in the cluster is enabled with the help of an administrator.</div>
<div>If the user does not supply a storage classification name, leave the pure volume Claim.storage ClassName field as nil.</div>
<div>This will provide a PV to the user in a regular cluster with the default StorageClass. Many cluster environments have a default StorageClass installed, or administrators can create their own Default StorageClass.</div>
<div>In your tooling, watch for PVCs that are not binding after some time and surface to the user, as this may indicate that the cluster has no dynamic storage support (in which case the user creates a matching <span id="page_59"></span>
 PV Is) or is in a cluster with no storage system (in which case the user does not need to be configured to require PVC).</div>
</body>
</html>
